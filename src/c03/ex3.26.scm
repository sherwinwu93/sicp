(define (make-tree key value left-branch right-branch)
  (list key value left-branch right-branch))
(define (tree-key tree)
  (car tree))
(define (tree-value tree)
  (cadr tree))
(define (tree-left-branch tree)
  (caddr tree))
(define (tree-right-branch tree)
  (cadddr tree))
(define (tree-set-key! tree new-key)
  (set-car! tree new-key))
(define (tree-set-value! tree new-value)
  (set-car! (cdr tree) new-value))
(define (tree-set-left-branch! tree new-left-branch)
  (set-car! (cddr tree) new-left-branch))
(define (tree-set-right-branch! tree new-right-branch)
  (set-car! (cdddr tree) new-right-branch))

(define (tree-empty? tree)
  (null? tree))

(define (tree-insert! tree given-key value compare)
  (let ((compare-result (compare given-key (tree-key tree))))
    (cond ((< compare-result 0)
	   (let ((subtree (tree-left-branch tree)))
	     (if (tree-empty? subtree)
		 (tree-set-left-branch! tree (make-tree given-key value () ()))
		 (tree-insert! subtree given-key value compare))
	     tree)
	   ((= compare-result 0)
	    (tree-set-value! tree value)
	    tree)
	   ((= compare-result 1)
	    (let ((subtree (tree-right-branch tree)))
	      (display (tree-empty? subtree))
	      (if (tree-empty? subtree)
		  (tree-set-right-branch! tree (make-tree given-key value () ()))
		  (tree-insert! subtree given-key value compare)))
	    tree)))))
(define (tree-insert! tree given-key value compare)
  (if (tree-empty? tree)
      (make-tree given-key value () ())
      (let ((compare-result (compare given-key (tree-key tree))))
	(cond ((= compare-result 0)
	       (tree-set-value! tree value)
	       tree)
	      ((= compare-result 1)
	       (tree-set-right-branch! tree
				       (tree-insert! (tree-right-branch tree) given-key value compare))
	       tree)
	      ((= compare-result -1)
	       (tree-set-left-branch! tree
				      (tree-insert! (tree-left-branch tree) given-key value compare))
	       tree)))))
(define t1 ())
(tree-insert! t1 2 22 compare-number)
t1

(define (tree-search tree given-key compare)
  (if (tree-empty? tree)
      false
      (let ((compare-result (compare given-key (tree-key tree))))
	(cond ((= compare-result 0) tree)
	      ((< compare-result 0) (tree-search (tree-left-branch tree) given-key compare))
	      ((> compare-result 0) (tree-search (tree-right-branch tree) given-key compare))))))

(define (compare-string x y)
  (cond ((string=? x y)
	 0)
	((string>? x y)
	 1)
	((string<? x y)
	 -1)))
(define (compare-symbol x y)
  (compare-string (symbol->string x)
		  (symbol->string y)))
(define (compare-number x y)
  (cond ((= x y) 0)
	((> x y) 1)
	((< x y) -1)))

(define (make-table compare)
  ;; empty?
  (let ((t ()))
    (define (empty?)
      (tree-empty? t))
    (define (insert! given-key value)
      (set! t (tree-insert! t given-key value compare))
      t)
    ;; (tree-insert! t given-key value compare)
    (define (lookup given-key)
      (let ((result (tree-search t given-key compare)))
	(if result
	    (tree-value result)
	    false)))
    (define (dispatch m)
      (cond ((eq? m 'empty?) empty?)
	    ((eq? m 'insert!) insert!)
	    ((eq? m 'lookup) lookup)
	    (else (error "Unknown operation table" m))))
    dispatch))
(define t (make-table compare-symbol))

((t 'insert!) 'a 1)
((t 'insert!) 'b 2)

((t 'empty?))

((t 'lookup) 'a)
