* Scheme入门教程
提供sicp的基础
* 安装scheme
* 将Scheme用作计算器
(+ 1 2)
;; 3
** 四种基本算术操作
- 分数转浮点数
(exact->inexact)
- 处理复数, a+bi ????

*** 练习1
1. (1+39)*(53-45)
(* (+ 1 39) (- 53 45)) 320

2. (1020/30)+(45*2)
(+ (/ 1020 30) (* 45 2)) 124

3. 求和:39, 48,72,23,91
(+ 39 48 72 23 91) 273

4. 求平均值:39, 48, 72, 23, 91(结果取浮点)
(exact->inexact (/ (+ 39 48 72 23 91) 5)) 54.6

*** 其他算术操作
**** 商`余数`平方根
- quotient 求商
- remainder 求余数
- sqrt 平方根(square root)
**** 三角函数
- sin
- atan
**** 指数和对数
- exp
- log

* 生成表
** 简介
基本的表操作: cons`car`cdr`list和quote(引用)
** Cons单元和表
*** Cons单元
存储两个地址的内存空间
(cons 1 2)
;; (1 . 2)
(cons 3 (cons 1 2))
;; (3 1 . 2)

- car:address
- cdr:decrement
*** 表
什么是表?
(cons 1 (cons 2 (cons 3 nil)))
递归定义的
写作:'(1 2 3) ????
*** 原子 atom
不使用cons单元的数据结构称为原子.数字,字符,字符串,向量和空表'()都是原子.'()即是原子,也是表

------------ 练习1
*** 引用
引用(quote): 阻止记号被求值.用符号或者表原封不动地传递给程序,而不是求值后变成其它的东西
例: (+ 2 3) -> 5, (quote (+ 2 3)) -> (+ 2 3) 等价于 '(+ 2 3), '()是对空表的引用
*** 特殊形式
两种不同类型的操作符:
1. 函数:对所有参数求值并返回值
2. 特殊形式:不会对所有参数求值.quote`lambda`define`if`set!,都是特殊形式
*** car函数和cdr函数
(car '(1 2 3 4))

---------- 练习2

* 定义函数
** 简介
(cd "/path")
(load "hello.scm")

** 定义有参数的函数
- string-append: 连接字符串

** 一种函数定义的短形式

------- 练习1




* 分支

** 简介

** if表达式
函数是否为空
(null? '())
; #t
(null? '(a b c))
; #f

if表达式: 如果predicate为真,则只有then_value部分被求值.是关键字.
new-if:是procedure,而if是关键字.procedure:会直接执行,if:会选择性执行

** and和or
and和or:不返回布尔值,而是返回给定参数之一

*** and
如果有一个为#f,就返回#f,不对剩余参数求值.如果都不是,则最后一个参数
(and #f 0) ->#f
(and 1 2 3) ->3
(and 1 2 3 #f) ->#f

*** or
返回第一个不是#f的参数,如果都是#f,则返回#f

** cond 表达式

*** 做出判断的函数
- eq? 比较内存地址
- eqv? 比较对象类型和值
- equals? 比较表或字符串序列

* 局部变量
** 简介
** let表达式
(let ((p1 v1) (p2 v2)...) body)

可多个
(let ((i 1) (j 2))
   (+ i j))
((lambda (i j) (+ i j)) 1 2)

可嵌套
(let ((i 1))
   (let ((j (+ i 2)))
      (* i j)))

作用域在body
(let ((i 1) (j (+ i 2)))
   (* i j))

let*语法糖=嵌套
(let* ((i 1) (j (+ i 2)))
   (* i j))

let实际是lambda表达式的语法糖
(let ((p1 v1) (p2 v2)...) exp1 exp2 ...)
=>
((lambda(p1 p2 ...)
    exp1 exp2 ...) v1 v2)

* 重复
** 简介
递归实现循环
** 递归
递归函数:自己定义自己.
计算阶乘
fact.scm






